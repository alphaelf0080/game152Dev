# Graphics Editor - 折線繪製 Undo/Redo 功能

## 🎯 新功能概述

折線繪製時現在支持 **撤銷/重做** 功能，並將完成折線的快捷鍵從 **ESC** 改為 **Enter**！

## ✨ 主要改進

### 1. 折線 Undo/Redo 支持
在繪製折線時，可以撤銷或重做已添加的點：
- ✅ **Ctrl + Z** - 撤銷最後一個點
- ✅ **Ctrl + Y** - 重做被撤銷的點
- ✅ 工具欄按鈕 - 「撤銷點」和「重做點」按鈕

### 2. 完成折線快捷鍵變更
- ❌ **舊：ESC 鍵完成折線**
- ✅ **新：Enter 鍵完成折線**
- 💡 **原因：** ESC 現在只用於取消選取，避免功能衝突

### 3. 智能按鈕狀態
- 沒有可撤銷的點時，「撤銷點」按鈕自動禁用
- 沒有可重做的點時，「重做點」按鈕自動禁用
- 少於 2 個點時，「完成折線」按鈕自動禁用

## 🎮 使用方法

### 基本流程

#### 1️⃣ 開始繪製折線
```
點擊「折線」工具按鈕 → 工具欄顯示三個新按鈕：
- 完成折線 (Enter)
- 撤銷點 (Ctrl+Z)
- 重做點 (Ctrl+Y)
```

#### 2️⃣ 添加點
```
在畫布上單擊 → 添加折線頂點
每次點擊：
- 藍色圓點標記頂點位置
- 自動連接前一個點
- 歷史記錄更新
```

#### 3️⃣ 撤銷點（如果點錯了）
```
方法 A：按 Ctrl + Z
方法 B：點擊「撤銷點 (Ctrl+Z)」按鈕

效果：移除最後添加的點，折線回到上一個狀態
```

#### 4️⃣ 重做點（如果撤銷錯了）
```
方法 A：按 Ctrl + Y
方法 B：點擊「重做點 (Ctrl+Y)」按鈕

效果：恢復被撤銷的點
```

#### 5️⃣ 完成折線
```
方法 A：按 Enter 鍵
方法 B：點擊「完成折線 (Enter)」按鈕

條件：至少需要 2 個點
效果：
- 折線完成並保存到圖形列表
- 三個折線按鈕自動隱藏
- 可以開始繪製下一個圖形
```

## ⌨️ 快捷鍵匯總

### 折線繪製中的快捷鍵

| 快捷鍵 | 功能 | 說明 |
|--------|------|------|
| **左鍵單擊** | 添加點 | 在畫布上添加折線頂點 |
| **Ctrl + Z** | 撤銷點 | 移除最後添加的點 |
| **Ctrl + Y** | 重做點 | 恢復被撤銷的點 |
| **Enter** | 完成折線 | 結束當前折線（需至少2點）|
| **ESC** | ~~完成折線~~ | ❌ 已移除此功能 |

### 通用快捷鍵（非折線繪製時）

| 快捷鍵 | 功能 | 說明 |
|--------|------|------|
| **右鍵點擊** | 選取圖形 | 選中已繪製的圖形 |
| **Ctrl + 左鍵** | 選取圖形 | 備用選取方式 |
| **Delete** | 刪除選中 | 刪除選中的圖形 |
| **ESC** | 取消選取 | 取消當前選取的圖形 |

## 🔍 技術細節

### 歷史記錄機制

```typescript
// 狀態變量
private polylineHistory: Array<Array<{x: number, y: number}>> = [];
private polylineHistoryIndex: number = -1;
```

#### 添加點時
```typescript
1. 將點添加到 polylinePoints 數組
2. 如果當前不在歷史末尾，刪除後續的歷史記錄（分支清理）
3. 深拷貝當前點數組到 polylineHistory
4. historyIndex++
5. 更新按鈕狀態
```

#### 撤銷時
```typescript
if (historyIndex > 0) {
    historyIndex--;
    polylinePoints = 深拷貝(polylineHistory[historyIndex]);
} else if (historyIndex === 0) {
    historyIndex = -1;
    polylinePoints = [];  // 回到起始狀態
}
```

#### 重做時
```typescript
if (historyIndex < polylineHistory.length - 1) {
    historyIndex++;
    polylinePoints = 深拷貝(polylineHistory[historyIndex]);
}
```

### 按鈕狀態管理

```typescript
updatePolylineButtons() {
    // 撤銷按鈕
    if (historyIndex >= 0) {
        btnPolylineUndo.enabled = true;
    } else {
        btnPolylineUndo.disabled = true;
    }
    
    // 重做按鈕
    if (historyIndex < history.length - 1) {
        btnPolylineRedo.enabled = true;
    } else {
        btnPolylineRedo.disabled = true;
    }
    
    // 完成按鈕
    if (polylinePoints.length >= 2) {
        btnClosePolyline.enabled = true;
    } else {
        btnClosePolyline.disabled = true;
    }
}
```

### 狀態重置

```typescript
closePolyline() {
    // 保存圖形...
    
    // 完全重置折線狀態
    this.isDrawingPolyline = false;
    this.polylinePoints = [];
    this.polylineHistory = [];
    this.polylineHistoryIndex = -1;
    
    // 隱藏所有折線按鈕
    btnClosePolyline.hide();
    btnPolylineUndo.hide();
    btnPolylineRedo.hide();
}
```

## 💡 使用場景

### 場景 1：精確繪製複雜形狀
```
目標：繪製一個複雜的多邊形

流程：
1. 開始折線工具
2. 依次點擊添加頂點
3. 哎呀，第 5 個點點錯了！
4. Ctrl + Z 撤銷錯誤的點
5. 重新點擊正確的位置
6. 繼續添加剩餘頂點
7. Enter 完成

結果：完美的多邊形，無需重新開始！
```

### 場景 2：實驗性調整
```
目標：不確定形狀的最佳頂點位置

流程：
1. 添加幾個基礎頂點
2. 嘗試添加一個頂點看效果
3. 效果不好？Ctrl + Z 撤銷
4. 嘗試另一個位置
5. 還是不好？Ctrl + Z 再撤銷
6. 或者 Ctrl + Y 恢復之前的嘗試
7. 找到最佳位置後 Enter 完成

結果：可以自由試驗而不用擔心犯錯！
```

### 場景 3：快速修正手滑
```
場景：快速繪製時手滑點錯

流程：
1. 快速連點添加頂點
2. 砰！手滑了，點偏了
3. 立即 Ctrl + Z（無需停頓）
4. 重新點擊正確位置
5. 繼續快速添加
6. Enter 完成

結果：流暢的繪製體驗，手滑不再是問題！
```

## 🎨 視覺反饋

### 按鈕狀態視覺

#### 可用狀態
```
[完成折線 (Enter)]  ← 正常藍色
[撤銷點 (Ctrl+Z)]   ← 正常顏色
[重做點 (Ctrl+Y)]   ← 正常顏色
```

#### 禁用狀態
```
[完成折線 (Enter)]  ← 灰色（< 2 個點時）
[撤銷點 (Ctrl+Z)]   ← 灰色（無可撤銷時）
[重做點 (Ctrl+Y)]   ← 灰色（無可重做時）
```

### 繪製過程視覺

```
添加第 1 個點：
● (藍色圓點)

添加第 2 個點：
●————● (連線 + 第二個點)

添加第 3 個點：
●————●
     │
     ● (形成折線)

撤銷後：
●————● (第 3 個點消失)

完成後：
正常的圖形（藍色點消失）
```

## 📊 歷史記錄示例

### 示例：繪製四邊形

```
操作序列：
1. 點擊 (100, 100) → history[0] = [{100,100}]
2. 點擊 (200, 100) → history[1] = [{100,100}, {200,100}]
3. 點擊 (200, 200) → history[2] = [{100,100}, {200,100}, {200,200}]
4. 點擊 (100, 200) → history[3] = [{100,100}, {200,100}, {200,200}, {100,200}]

當前狀態：
history = [狀態0, 狀態1, 狀態2, 狀態3]
historyIndex = 3

按 Ctrl+Z：
historyIndex = 2
當前點 = 狀態2 = 3個點

再按 Ctrl+Z：
historyIndex = 1
當前點 = 狀態1 = 2個點

按 Ctrl+Y：
historyIndex = 2
當前點 = 狀態2 = 3個點

添加新點 (150, 150)：
history = [狀態0, 狀態1, 狀態2, 狀態4新]  ← 狀態3被覆蓋
historyIndex = 3
```

## ⚠️ 注意事項

### 注意 1：歷史分支處理
```
如果在歷史中間添加新點，後續的歷史會被清除：

原始：點1 → 點2 → 點3 → 點4
撤銷：點1 → 點2 → 點3 ← 當前
添加：點1 → 點2 → 點3 → 點5新（點4消失）

這是標準的 undo/redo 行為
```

### 注意 2：完成折線後歷史清空
```
完成折線（Enter）後：
- 歷史記錄立即清空
- 無法撤銷到折線繪製中的狀態
- 只能通過「撤銷」按鈕刪除整個折線

建議：完成前確認折線正確
```

### 注意 3：最小點數限制
```
折線必須至少有 2 個點才能完成
- 0 點：「完成折線」按鈕禁用
- 1 點：「完成折線」按鈕禁用
- 2+ 點：「完成折線」按鈕啟用
```

### 注意 4：快捷鍵衝突避免
```
折線繪製中：
- Ctrl+Z → 折線撤銷點（優先）
- Ctrl+Y → 折線重做點（優先）
- Enter → 完成折線

非折線繪製時：
- Ctrl+Z → 無效（避免誤操作）
- ESC → 取消選取
```

## 🔄 與其他功能的整合

### 與選取功能
```
折線繪製中：
- 右鍵/Ctrl+左鍵 → 仍然是添加點（不是選取）
- 選取功能暫時不可用

折線完成後：
- 可以右鍵選取並刪除整個折線
```

### 與全局撤銷
```
「撤銷」按鈕（工具欄）：
- 刪除最後一個完整圖形（包括折線）

「撤銷點」按鈕（折線中）：
- 只在折線繪製時可見
- 只撤銷折線中的點
- 不影響其他圖形
```

### 與清空功能
```
「清空」按鈕：
- 不會中斷正在繪製的折線
- 只清除已完成的圖形

「清空所有繪圖」按鈕：
- 清除所有已完成的圖形
- 不影響正在繪製的折線
```

## 🚀 效能優化

### 深拷貝優化
```typescript
// 使用 JSON 深拷貝（簡單有效）
history.push(JSON.parse(JSON.stringify(points)));

優點：
- 完全獨立的副本
- 避免引用問題
- 實現簡單

缺點：
- 較慢（但對少量點影響不大）

適用範圍：
- 折線通常 < 100 個點
- 效能完全可接受
```

### 歷史記錄限制
```
當前：無限制
未來可優化：
- 最多保存 100 個狀態
- 超過時移除最舊的狀態
```

## 📈 改進建議

### 未來可能添加的功能
- [ ] 顯示歷史步數（如 "3/7"）
- [ ] Ctrl + Shift + Z 作為 Redo 的備用鍵
- [ ] 撤銷/重做動畫效果
- [ ] 歷史記錄面板（顯示所有狀態）
- [ ] 跳轉到任意歷史狀態

## 🎉 總結

### 核心優勢
✅ **直觀操作** - Ctrl+Z/Y 符合普遍習慣  
✅ **無縫整合** - 不影響其他功能  
✅ **智能反饋** - 按鈕狀態自動更新  
✅ **容錯友好** - 可以自由試驗，不怕犯錯  
✅ **完整歷史** - 支持多步撤銷/重做  

### 快捷鍵變更
❌ **ESC 完成折線** → ✅ **Enter 完成折線**  
💡 更符合「確認」的語義，ESC 保留給「取消」操作

現在繪製折線更加靈活方便了！🎨✨
