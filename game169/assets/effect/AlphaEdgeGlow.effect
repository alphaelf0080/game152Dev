// Alpha Edge Glow Shader - 沿著 Alpha 邊緣的發光效果
// 適用於 Sprite，創建邊緣發光效果
// Cocos Creator 3.8

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        mainTexture: { value: white }
        glowColor: { value: [1.0, 1.0, 0.5, 1.0], editor: { displayName: 'Glow Color', type: color } }
        glowWidth: { value: 0.15, editor: { displayName: 'Glow Width', range: [0.01, 1.0], step: 0.01 } }
        glowIntensity: { value: 2.0, editor: { displayName: 'Glow Intensity', range: [0.0, 5.0], step: 0.1 } }
        glowPulseSpeed: { value: 2.0, editor: { displayName: 'Glow Pulse Speed', range: [0.0, 10.0], step: 0.1 } }
        sampleOffset: { value: 1.0, editor: { displayName: 'Edge Detection', range: [0.5, 3.0], step: 0.1 } }
        distortionStrength: { value: 0.5, editor: { displayName: 'Glow Distortion Strength', range: [0.0, 1.0], step: 0.01 } }
        distortionSpeed: { value: 2.0, editor: { displayName: 'Glow Distortion Speed', range: [0.0, 10.0], step: 0.1 } }
        distortionFrequency: { value: 5.0, editor: { displayName: 'Glow Distortion Frequency', range: [1.0, 30.0], step: 0.5 } }
        shineIntensity: { value: 2.0, editor: { displayName: 'Edge Shine Intensity', range: [0.0, 10.0], step: 0.1 } }
        shineSpeed: { value: 3.0, editor: { displayName: 'Edge Shine Speed', range: [0.0, 10.0], step: 0.1 } }
        shineWidth: { value: 1.0, editor: { displayName: 'Edge Shine Width (px scale)', range: [0.1, 10.0], step: 0.1 } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 v_color;
  out vec2 v_uv0;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    pos = cc_matViewProj * pos;

    v_uv0 = a_texCoord;
    v_color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  in vec4 v_color;
  in vec2 v_uv0;

  uniform sampler2D mainTexture;

  uniform Constant {
    vec4 glowColor;
    float glowWidth;
    float glowIntensity;
    float glowPulseSpeed;
    float sampleOffset;
    float distortionStrength;
    float distortionSpeed;
    float distortionFrequency;
    float shineIntensity;
    float shineSpeed;
    float shineWidth;
  };

  vec4 frag () {
    // 原始 sprite 使用正常 UV，不變形
    vec4 o = texture(mainTexture, v_uv0);
    float centerAlpha = o.a;
    
    // 計算紋理偏移
    vec2 texelSize = vec2(sampleOffset / 512.0);
    
    // 邊緣檢測：採樣周圍像素（使用原始 UV）
    float minAlpha = 1.0;
    minAlpha = min(minAlpha, texture(mainTexture, v_uv0 + vec2(texelSize.x, 0.0)).a);
    minAlpha = min(minAlpha, texture(mainTexture, v_uv0 + vec2(-texelSize.x, 0.0)).a);
    minAlpha = min(minAlpha, texture(mainTexture, v_uv0 + vec2(0.0, texelSize.y)).a);
    minAlpha = min(minAlpha, texture(mainTexture, v_uv0 + vec2(0.0, -texelSize.y)).a);
    
    // 邊緣強度
    float edgeStrength = centerAlpha * (1.0 - minAlpha);
    
    // 應用顏色
    o.rgb *= v_color.rgb;
    o.a *= v_color.a;
    
    ALPHA_TEST(o);

    // 邊緣發光效果（只有 glow 會變形）
    if (centerAlpha > 0.01 && edgeStrength > 0.01) {
      // 脈衝動畫
      float pulse = 1.0;
      if (glowPulseSpeed > 0.001) {
        pulse = 0.5 + 0.5 * sin(cc_time.x * glowPulseSpeed);
      }
      
      // 計算發光強度
      float glowFactor = smoothstep(0.0, glowWidth, edgeStrength);
      glowFactor *= pulse * glowIntensity;
      
      // 對 glow 顏色應用扭曲變形
      vec3 glowColorFinal = glowColor.rgb;
      float glowWidthFinal = glowWidth;
      float glowMask = 1.0; // 用於完全遮蔽某些區域
      
      if (distortionStrength > 0.001) {
        float distortTime = cc_time.x * distortionSpeed;
        
        // 計算沿邊緣的角度位置（用於圓形分布）
        float angle = atan(v_uv0.y - 0.5, v_uv0.x - 0.5);
        float normalizedAngle = (angle + 3.14159) / 6.28318; // 0-1 範圍
        
        // 創建更極端的不連續段落
        float segmentPattern = sin(normalizedAngle * distortionFrequency * 3.0 + distortTime);
        segmentPattern += sin(normalizedAngle * distortionFrequency * 5.0 - distortTime * 1.3) * 0.7;
        segmentPattern += sin(normalizedAngle * distortionFrequency * 8.0 + distortTime * 1.7) * 0.5;
        segmentPattern += cos(normalizedAngle * distortionFrequency * 11.0 + distortTime * 2.1) * 0.4;
        
        // 添加更多隨機噪聲層
        float noise1 = fract(sin(normalizedAngle * 50.0 + distortTime * 3.0) * 43758.5453);
        float noise2 = fract(sin(normalizedAngle * 73.0 + distortTime * 2.3) * 12345.6789);
        float noise3 = fract(cos(normalizedAngle * 91.0 + distortTime * 1.7) * 98765.4321);
        float combinedNoise = (noise1 + noise2 + noise3) * 0.333;
        
        segmentPattern += (combinedNoise - 0.5) * 1.5; // 增加隨機性
        
        // 使用更極端的閾值創建斷續效果
        float threshold = 0.5 - distortionStrength * 0.4;
        glowMask = smoothstep(threshold - 0.2, threshold + 0.2, segmentPattern);
        
        // 添加多層快速閃爍的斷點
        float flicker1 = sin(normalizedAngle * 20.0 + distortTime * 5.0);
        flicker1 = step(0.7, flicker1);
        
        float flicker2 = cos(normalizedAngle * 35.0 - distortTime * 7.0);
        flicker2 = step(0.75, flicker2);
        
        float flicker3 = sin(normalizedAngle * 50.0 + distortTime * 9.0);
        flicker3 = step(0.8, flicker3);
        
        float flickerCombined = flicker1 * flicker2 * (0.5 + flicker3 * 0.5);
        glowMask *= (0.1 + flickerCombined * 0.9); // 更極端，有些地方幾乎消失
        
        // 沿邊緣的極端寬度變化
        float widthWave = sin(normalizedAngle * distortionFrequency * 2.5 + distortTime * 0.8);
        widthWave += cos(normalizedAngle * distortionFrequency * 4.0 - distortTime * 1.2) * 0.6;
        widthWave += sin(normalizedAngle * distortionFrequency * 7.0 + distortTime * 1.5) * 0.4;
        widthWave += cos(normalizedAngle * distortionFrequency * 10.0 + distortTime * 2.0) * 0.3;
        
        // 添加突發的超寬區域
        float widthBurst = sin(normalizedAngle * 15.0 + distortTime * 1.5);
        widthBurst = pow(max(0.0, widthBurst), 5.0) * 3.0;
        
        // 極端的寬度變化：從很細到超寬
        float widthMod = 0.2 + pow(abs(widthWave), 1.2) * 3.0 + widthBurst;
        widthMod *= (1.0 + combinedNoise * 2.0); // 添加噪聲讓寬度更不規則
        glowWidthFinal *= widthMod * (1.0 + distortionStrength * 2.0);
        
        // 強度的極端變化
        float intensityWave = sin(normalizedAngle * distortionFrequency * 1.5 + distortTime * 0.6);
        intensityWave = pow(abs(intensityWave), 1.5);
        
        // 添加更多隨機亮點和暗點
        float sparkle = fract(sin(floor(normalizedAngle * 30.0) + distortTime * 0.3) * 43758.5453);
        sparkle = step(0.8, sparkle); // 20% 的位置會有超亮點
        
        float darkSpot = fract(cos(floor(normalizedAngle * 25.0) - distortTime * 0.4) * 12345.6789);
        darkSpot = step(0.85, darkSpot); // 15% 的位置會特別暗
        
        float intensityMod = 0.3 + intensityWave * 2.0 + sparkle * 5.0 - darkSpot * 0.5;
        intensityMod *= (1.0 + combinedNoise); // 添加噪聲
        glowMask *= intensityMod * (1.0 + distortionStrength * 3.0);
        
        // 顏色強度的極端變化
        glowColorFinal *= (0.5 + intensityWave * 0.8 + sparkle * 2.0);
        
        // 添加更明顯的顆粒紋理
        float grain = fract(sin(normalizedAngle * 150.0 + distortTime * 15.0) * 43758.5453);
        grain = smoothstep(0.2, 0.8, grain);
        glowMask *= (0.5 + grain * 0.5);
        
        // 添加大塊的消失區域
        float largeGap = sin(normalizedAngle * distortionFrequency * 0.8 + distortTime * 0.3);
        largeGap = smoothstep(-0.5, -0.2, largeGap);
        glowMask *= (0.1 + largeGap * 0.9);
      }
      
      // 重新計算發光強度（使用動態寬度）
      float finalGlowFactor = smoothstep(0.0, glowWidthFinal, edgeStrength);
      finalGlowFactor *= pulse * glowIntensity;
      
      // 應用遮蔽效果（斷續效果）
      finalGlowFactor *= glowMask;
      
      // 添加發光
      o.rgb += glowColorFinal * finalGlowFactor;
      
      // === Edge Shine 效果 - 額外的外圍光暈 ===
      if (shineIntensity > 0.01 && edgeStrength > 0.001) {
        float shineTime = cc_time.x * shineSpeed;
        
        // 計算角度位置
        float angle = atan(v_uv0.y - 0.5, v_uv0.x - 0.5);
        float normalizedAngle = (angle + 3.14159) / 6.28318;
        
        // 創建流動的亮點
        float shineWave = sin(normalizedAngle * 8.0 + shineTime);
        shineWave += sin(normalizedAngle * 12.0 - shineTime * 1.3) * 0.7;
        shineWave += cos(normalizedAngle * 15.0 + shineTime * 1.7) * 0.5;
        shineWave = pow(max(0.0, shineWave), 2.0);
        
        // 添加快速移動的閃光點
        float sparklePos = fract(shineTime * 0.2);
        float angleToSparkle = abs(normalizedAngle - sparklePos);
        angleToSparkle = min(angleToSparkle, 1.0 - angleToSparkle);
        float sparkle = 1.0 - smoothstep(0.0, 0.1, angleToSparkle);
        sparkle = pow(sparkle, 3.0);
        
        // 添加多個隨機閃光點
        float randomSparkle = 0.0;
        for(float i = 0.0; i < 5.0; i += 1.0) {
          float sparkleAngle = fract(sin(i * 12.345 + shineTime * 0.3) * 43758.5453);
          float dist = abs(normalizedAngle - sparkleAngle);
          dist = min(dist, 1.0 - dist);
          float spark = 1.0 - smoothstep(0.0, 0.05, dist);
          randomSparkle += pow(spark, 4.0);
        }
        
        // 組合所有 shine 效果
        float shineFactor = (shineWave + sparkle * 3.0 + randomSparkle * 2.0) * 0.5;
        
        // 擴展的外圍光暈 - 讓範圍更大更明顯
        // 使用更大的倍數來擴展範圍
        float expandedEdge = edgeStrength * shineWidth * 5.0;
        float outerGlow = smoothstep(0.0, 1.0, expandedEdge);
        outerGlow = pow(outerGlow, 0.3); // 降低次方讓外圍更明顯
        
        // 添加多層漸變光暈
        float layer1 = smoothstep(0.0, shineWidth * 0.5, expandedEdge) * 2.0;
        float layer2 = smoothstep(0.0, shineWidth * 1.0, expandedEdge) * 1.5;
        float layer3 = smoothstep(0.0, shineWidth * 2.0, expandedEdge) * 1.0;
        
        outerGlow = max(outerGlow, (layer1 + layer2 + layer3) * 0.3);
        
        shineFactor = (shineFactor + 1.0) * outerGlow * shineIntensity * 2.0;
        
        // 添加強烈的白色 shine
        vec3 shineColor = vec3(1.0, 1.0, 1.0);
        
        // 讓 shine 也受到扭曲影響（如果有開啟）
        if (distortionStrength > 0.001) {
          shineFactor *= (glowMask * 0.3 + 0.7);
        }
        
        o.rgb += shineColor * shineFactor * centerAlpha;
      }
    }

    return o;
  }
}%
