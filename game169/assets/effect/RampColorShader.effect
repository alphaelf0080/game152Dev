// Ramp Color Shader - 支援 Ramp 顏色調整、多種方向、UV 控制和混合模式
// 適用於 Cocos Creator 3.8

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        
        # 主紋理 UV 控制
        mainTexture: { 
          value: white, 
          editor: { displayName: '主紋理' }
        }
        tilingOffset: { value: [1.0, 1.0, 0.0, 0.0], editor: { displayName: 'Tiling & Offset', tooltip: 'XY=Sprite Tiling數量 (Simple=1,1 | Tiled3x3=3,3) **必須設定** | ZW=Ramp基礎偏移' } }
        useMainTexture: { value: 0.0, editor: { displayName: '使用主紋理', tooltip: '1=使用主紋理, 0=不使用' } }
        
        # Ramp 紋理和顏色控制
        rampTexture: { 
          value: white, 
          editor: { displayName: 'Ramp 紋理', tooltip: '用於顏色映射的 Ramp 紋理' },
          sampler: {
            minFilter: linear,
            magFilter: linear,
            mipFilter: none,
            addressU: repeat,
            addressV: repeat
          }
        }
        useRampTexture: { value: 0.0, editor: { displayName: '使用 Ramp 紋理', tooltip: '1=使用紋理, 0=使用顏色漸變' } }
        
        # 顏色漸變設置（當不使用 Ramp 紋理時）
        colorStart: { value: [0.0, 0.0, 0.0, 1.0], editor: { type: color, displayName: '起始顏色' } }
        colorEnd: { value: [1.0, 1.0, 1.0, 1.0], editor: { type: color, displayName: '結束顏色' } }
        
        # Ramp 範圍控制
        rampCenter: { value: [0.5, 0.5], editor: { displayName: 'Ramp 中心點', tooltip: '圓形/徑向模式的中心點' } }
        rampUVScale: { value: [1.0, 1.0], editor: { displayName: 'Ramp UV Tiling', tooltip: 'Ramp效果的重複次數 (1=不重複, 2=重複2x2, 3=重複3x3)' } }
        rampUVOffset: { value: [0.0, 0.0], editor: { displayName: 'Ramp UV Offset', tooltip: 'Ramp效果的偏移' } }
        rampRange: { value: [0.0, 1.0], editor: { displayName: 'Ramp 範圍', tooltip: 'X=起始位置, Y=結束位置' } }
        
        # 顏色調整
        brightness: { value: 0.0, editor: { range: [-1.0, 1.0], slide: true, displayName: '亮度調整' } }
        contrast: { value: 1.0, editor: { range: [0.0, 3.0], slide: true, displayName: '對比度' } }
        saturation: { value: 1.0, editor: { range: [0.0, 3.0], slide: true, displayName: '飽和度' } }
        
        # 強度控制
        rampIntensity: { value: 1.0, editor: { range: [0.0, 2.0], slide: true, displayName: 'Ramp 強度' } }
        
        # 進階控制
        invertRamp: { value: 0.0, editor: { displayName: '反轉 Ramp', tooltip: '1=反轉漸變方向' } }
        smoothness: { value: 0.0, editor: { range: [0.0, 1.0], slide: true, displayName: '平滑度', tooltip: '邊緣平滑程度' } }
        
        # 長方形 Ramp 控制（RAMP_DIRECTION = 4 或 5 時使用）
        rectangleAspect: { value: [1.0, 1.0], editor: { displayName: '長方形寬高比', tooltip: 'X=寬度, Y=高度' } }
        cornerRadius: { value: 0.0, editor: { range: [0.0, 2.0], slide: true, step: 0.01, displayName: '圓角半徑', tooltip: '0=直角, 值越大圓角越大' } }
        
        # 扭曲變形控制
        distortionIntensity: { value: 0.0, editor: { range: [0.0, 1.0], slide: true, step: 0.01, displayName: '扭曲強度', tooltip: '扭曲變形的強度' } }
        distortionFrequency: { value: 5.0, editor: { range: [1.0, 20.0], slide: true, step: 0.1, displayName: '扭曲頻率', tooltip: '扭曲變形的頻率/細節' } }
}%

CCProgram sprite-vs %{
  precision mediump float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  #if SAMPLE_FROM_RT
    #include <common/common-define>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 color;
  out vec2 uv0;
  out vec2 effectUV;     // Ramp effect 專用 UV（獨立系統，0-1 範圍）
  out vec2 tileInfo;     // Tile 索引資訊

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    #if USE_PIXEL_ALIGNMENT
      pos = cc_matView * pos;
      pos.xyz = floor(pos.xyz);
      pos = cc_matProj * pos;
    #else
      pos = cc_matViewProj * pos;
    #endif

    uv0 = a_texCoord;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(uv0);
    #endif
    
    // effectUV: Ramp effect 專用的獨立 UV 座標系統
    // 無論 Sprite 是 SIMPLE 或 TILED，effectUV 永遠在 0-1 範圍內
    // fract() 確保每個 tile 都有完整的 0-1 UV 空間
    effectUV = fract(a_texCoord);
    
    // tileInfo: 記錄當前是第幾個 tile（用於 TILED sprite）
    // floor(a_texCoord) 給出 tile 的索引
    // SIMPLE sprite: (0, 0)
    // TILED 3x3 sprite: (0,0) ~ (2,2)
    tileInfo = floor(a_texCoord);
    
    color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision mediump float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>
  
  // 使用 macro 定義下拉選單選項
  #pragma define-meta RAMP_DIRECTION range([0, 5])
  #pragma define-meta BLEND_MODE range([0, 15])
  
  in vec4 color;
  in vec2 uv0;
  in vec2 effectUV;
  in vec2 tileInfo;  // 新增：tile 索引資訊
  
  #if USE_TEXTURE
    #pragma builtin(local)
    layout(set = 2, binding = 12) uniform sampler2D cc_spriteTexture;
  #endif
  
  uniform sampler2D mainTexture;
  uniform sampler2D rampTexture;
  
  uniform RampProperties {
    vec4 tilingOffset;      // xy = tiling(repeat), zw = offset
    vec4 colorStart;
    vec4 colorEnd;
    vec2 rampCenter;
    vec2 rampUVScale;
    vec2 rampUVOffset;
    vec2 rampRange;
    vec2 rectangleAspect;   // 長方形寬高比
    float cornerRadius;     // 圓角半徑
    float useRampTexture;
    float useMainTexture;
    float brightness;
    float contrast;
    float saturation;
    float rampIntensity;
    float invertRamp;
    float smoothness;
    float distortionIntensity;  // 扭曲強度
    float distortionFrequency;  // 扭曲頻率
  };
  
  // 簡化的噪聲函數（基於 hash）
  float hash(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
  }
  
  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);
    
    // 平滑插值
    f = f * f * (3.0 - 2.0 * f);
    
    // 四個角落的噪聲值
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    
    // 雙線性插值
    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
  }
  
  // RGB 轉 HSV
  vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }
  
  // HSV 轉 RGB
  vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
  }
  
  // 顏色調整函數
  vec3 adjustColor(vec3 inputColor) {
    // 亮度調整
    vec3 result = inputColor + brightness;
    
    // 對比度調整
    result = (result - 0.5) * contrast + 0.5;
    
    // 飽和度調整
    if (saturation != 1.0) {
      vec3 hsv = rgb2hsv(result);
      hsv.y *= saturation;
      result = hsv2rgb(hsv);
    }
    
    return clamp(result, 0.0, 1.0);
  }
  
  // 計算 Ramp 座標
  float calculateRampCoord(vec2 uv) {
    // uv 參數就是 effectUV，已經在 vertex shader 中通過 fract() 處理過
    // 它的範圍永遠是 0-1（每個 tile 內的 UV）
    
    vec2 tileCount = max(tilingOffset.xy, vec2(1.0, 1.0));
    
    // uv 已經是 tile 內的 UV (0-1)，不需要再 fract()
    vec2 uvInTile = uv;
    
    // 計算全域 UV：將 tile 索引和 tile 內 UV 組合
    // 對於 TILED 3x3 的中心 tile:
    //   tileInfo = (1, 1)
    //   uvInTile = (0.5, 0.5)
    //   globalUV = (1.5, 1.5) / (3, 3) = (0.5, 0.5) ✅
    vec2 globalUV = (tileInfo + uvInTile) / tileCount;
    
    // 第二步：應用基礎偏移（tilingOffset.zw）
    vec2 baseUV = globalUV + tilingOffset.zw;
    
    // 第三步：應用 Ramp UV Tiling（重複）和 Offset
    // rampUVScale 現在是相對於整個 Sprite 的重複次數
    vec2 rampUV = fract(baseUV * rampUVScale) + rampUVOffset;
    
    // 第四步：應用扭曲變形
    if (distortionIntensity > 0.0) {
      vec2 distortionOffset = vec2(
        noise(rampUV * distortionFrequency) - 0.5,
        noise(rampUV * distortionFrequency + vec2(17.3, 29.7)) - 0.5
      );
      rampUV += distortionOffset * distortionIntensity * 0.1;
    }
    
    // transformedUV 用於後續的 Ramp 計算
    vec2 transformedUV = rampUV;
    
    float rampCoord = 0.0;
    
    // 使用 macro RAMP_DIRECTION
    #if RAMP_DIRECTION == 0
      // 水平 Ramp
      rampCoord = transformedUV.x;
    #elif RAMP_DIRECTION == 1
      // 垂直 Ramp
      rampCoord = transformedUV.y;
    #elif RAMP_DIRECTION == 2
      // 圓形 Ramp（從中心向外）
      vec2 centeredUV = transformedUV - rampCenter;
      rampCoord = length(centeredUV);
    #elif RAMP_DIRECTION == 3
      // 徑向 Ramp（角度漸變）
      vec2 centeredUV = transformedUV - rampCenter;
      rampCoord = (atan(centeredUV.y, centeredUV.x) + 3.14159) / (2.0 * 3.14159);
    #elif RAMP_DIRECTION == 4
      // 長方形內縮 Ramp（從邊緣向中心）
      vec2 centeredUV = transformedUV - rampCenter;
      
      // 根據寬高比調整 UV
      vec2 aspectUV = centeredUV / rectangleAspect;
      
      // 計算到長方形邊緣的距離（帶圓角）
      vec2 halfSize = vec2(0.5, 0.5);
      vec2 cornerOffset = abs(aspectUV) - halfSize + cornerRadius;
      
      // 計算圓角距離場
      float outsideDist = length(max(cornerOffset, 0.0));
      float insideDist = min(max(cornerOffset.x, cornerOffset.y), 0.0);
      float dist = outsideDist + insideDist - cornerRadius;
      
      // 距離越大（越靠近邊緣），rampCoord 越小（內縮效果）
      // 正規化到 0-1 範圍，0 = 邊緣，1 = 中心
      rampCoord = 1.0 - clamp(dist * 2.0 + 1.0, 0.0, 1.0);
      
    #elif RAMP_DIRECTION == 5
      // 長方形外擴 Ramp（從中心向邊緣）
      vec2 centeredUV = transformedUV - rampCenter;
      
      // 根據寬高比調整 UV
      vec2 aspectUV = centeredUV / rectangleAspect;
      
      // 計算到長方形邊緣的距離（帶圓角）
      vec2 halfSize = vec2(0.5, 0.5);
      vec2 cornerOffset = abs(aspectUV) - halfSize + cornerRadius;
      
      // 計算圓角距離場
      float outsideDist = length(max(cornerOffset, 0.0));
      float insideDist = min(max(cornerOffset.x, cornerOffset.y), 0.0);
      float dist = outsideDist + insideDist - cornerRadius;
      
      // 距離越大（越靠近邊緣），rampCoord 越大（外擴效果）
      // 正規化到 0-1 範圍，0 = 中心，1 = 邊緣
      rampCoord = clamp(dist * 2.0 + 1.0, 0.0, 1.0);
    #endif
    
    // 應用範圍映射
    float rangeStart = rampRange.x;
    float rangeEnd = rampRange.y;
    rampCoord = (rampCoord - rangeStart) / (rangeEnd - rangeStart);
    
    // 限制到 0-1 範圍
    rampCoord = clamp(rampCoord, 0.0, 1.0);
    
    // 應用反轉
    if (invertRamp > 0.5) {
      rampCoord = 1.0 - rampCoord;
    }
    
    // 應用平滑度
    if (smoothness > 0.0) {
      rampCoord = smoothstep(0.0, 1.0, rampCoord);
      // 進一步平滑
      rampCoord = mix(rampCoord, smoothstep(0.0, 1.0, rampCoord), smoothness);
    }
    
    return rampCoord;
  }
  
  // 獲取 Ramp 顏色
  vec3 getRampColor(float rampCoord) {
    vec3 rampColor;
    
    if (useRampTexture > 0.5) {
      // 使用 Ramp 紋理
      rampColor = texture(rampTexture, vec2(rampCoord, 0.5)).rgb;
    } else {
      // 使用顏色漸變
      rampColor = mix(colorStart.rgb, colorEnd.rgb, rampCoord);
    }
    
    return adjustColor(rampColor);
  }
  
  // 輔助函數：獲取亮度值
  float getLuminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
  }
  
  // 輔助函數：設置指定顏色的亮度值
  vec3 setLuminance(vec3 c, float l) {
    float d = l - getLuminance(c);
    return c + vec3(d);
  }
  
  // 輔助函數：計算顏色的飽和度
  float getSaturation(vec3 c) {
    return max(max(c.r, c.g), c.b) - min(min(c.r, c.g), c.b);
  }
  
  // 輔助函數：飽和度調整
  vec3 setSaturationValue(vec3 c, float s) {
    float l = getLuminance(c);
    vec3 grey = vec3(l);
    return mix(grey, c, s);
  }
  
  // 混合模式函數
  vec3 applyBlendMode(vec3 base, vec3 blend, float intensity) {
    vec3 result = base;
    
    const float EPSILON = 0.00001;  // 防止除零錯誤
    
    #if BLEND_MODE == 0
      // Normal - 正常混合
      result = mix(base, blend, intensity);
    #elif BLEND_MODE == 1
      // Multiply - 正片疊底
      result = mix(base, base * blend, intensity);
    #elif BLEND_MODE == 2
      // Screen - 濾色
      vec3 screenResult = blend + base * (vec3(1.0) - blend);
      result = mix(base, screenResult, intensity);
    #elif BLEND_MODE == 3
      // Overlay - 疊加
      vec3 overlayResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, base)
      );
      result = mix(base, overlayResult, intensity);
    #elif BLEND_MODE == 4
      // Darken - 變暗
      result = mix(base, min(base, blend), intensity);
    #elif BLEND_MODE == 5
      // Lighten - 變亮
      result = mix(base, max(base, blend), intensity);
    #elif BLEND_MODE == 6
      // Color Dodge - 顏色減淡
      vec3 dodgeResult = base / max(vec3(EPSILON), vec3(1.0) - blend);
      result = mix(base, dodgeResult, intensity);
    #elif BLEND_MODE == 7
      // Color Burn - 顏色加深
      vec3 burnResult = vec3(1.0) - (vec3(1.0) - base) / max(vec3(EPSILON), blend);
      result = mix(base, burnResult, intensity);
    #elif BLEND_MODE == 8
      // Hard Light - 強光
      vec3 hardLightResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, blend)
      );
      result = mix(base, hardLightResult, intensity);
    #elif BLEND_MODE == 9
      // Soft Light - 柔光（Photoshop 公式）
      vec3 usePoly = step(base, vec3(0.25));
      vec3 Gpoly = ((vec3(16.0) * base - vec3(12.0)) * base + vec3(4.0)) * base;
      vec3 G = usePoly * Gpoly + (vec3(1.0) - usePoly) * sqrt(base);
      
      vec3 A = base - (vec3(1.0) - 2.0 * blend) * base * (vec3(1.0) - base);
      vec3 B = base + (2.0 * blend - vec3(1.0)) * (G - base);
      
      vec3 softLightResult = mix(A, B, step(vec3(0.5), blend));
      result = mix(base, softLightResult, intensity);
    #elif BLEND_MODE == 10
      // Difference - 差值
      result = mix(base, abs(base - blend), intensity);
    #elif BLEND_MODE == 11
      // Exclusion - 排除
      vec3 exclusionResult = base + blend - 2.0 * base * blend;
      result = mix(base, exclusionResult, intensity);
    #elif BLEND_MODE == 12
      // Hue - 色相
      float s = getSaturation(base);
      float l = getLuminance(base);
      vec3 hueResult = setLuminance(setSaturationValue(blend, s), l);
      result = mix(base, hueResult, intensity);
    #elif BLEND_MODE == 13
      // Saturation - 飽和度
      float s = getSaturation(blend);
      float l = getLuminance(base);
      vec3 satResult = setLuminance(setSaturationValue(base, s), l);
      result = mix(base, satResult, intensity);
    #elif BLEND_MODE == 14
      // Color - 顏色
      vec3 colorResult = setLuminance(blend, getLuminance(base));
      result = mix(base, colorResult, intensity);
    #elif BLEND_MODE == 15
      // Luminosity - 亮度
      vec3 lumResult = setLuminance(base, getLuminance(blend));
      result = mix(base, lumResult, intensity);
    #endif
    
    return clamp(result, 0.0, 1.0);
  }
  
  vec4 frag () {
    vec4 o = vec4(1, 1, 1, 1);
    
    #if USE_TEXTURE
      // Sprite 紋理使用原始 UV（不受 tilingOffset 影響）
      o *= CCSampleWithAlphaSeparated(cc_spriteTexture, uv0);
      #if IS_GRAY
        float gray = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;
        o.r = o.g = o.b = gray;
      #endif
    #endif
    
    // 如果啟用主紋理，採樣並混合
    if (useMainTexture > 0.5) {
      vec2 mainUV = fract(uv0 * tilingOffset.xy) + tilingOffset.zw;
      vec4 mainTexColor = texture(mainTexture, mainUV);
      o.rgb *= mainTexColor.rgb;
      o.a *= mainTexColor.a;
    }
    
    // 計算 Ramp 座標（使用 effectUV，不受 Sprite 紋理 UV 影響）
    float rampCoord = calculateRampCoord(effectUV);
    
    // 獲取 Ramp 顏色
    vec3 rampColor = getRampColor(rampCoord);
    
    // 應用 Ramp 混合模式（base=原始紋理, blend=rampColor）
    o.rgb = applyBlendMode(o.rgb, rampColor, rampIntensity);
    
    // 應用頂點顏色
    o *= color;
    
    ALPHA_TEST(o);
    return o;
  }
}%