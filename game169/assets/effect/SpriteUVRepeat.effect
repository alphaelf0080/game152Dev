// Sprite UV Repeat Shader with Second Layer
// 支援第二層獨立紋理，擁有獨立的 UV 系統
// Cocos Creator 3.8

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        
        # 第一層（底層）紋理
        mainTexture: { value: white }
        tilingOffset: { value: [1.0, 1.0, 0.0, 0.0] }
        
        # 第二層（頂層）紋理 - 獨立 UV 系統
        layerTexture: { value: white }
        layerTilingOffset: { value: [1.0, 1.0, 0.0, 0.0] }
        layerUVScale: { value: [1.0, 1.0, 0.0, 0.0], editor: { displayName: 'Layer UV Scale' } }
        layerOpacity: { value: 100.0, editor: { displayName: 'Layer Opacity', range: [0, 100], step: 1 } }
        useLayer: { value: 1.0 }
        layerBlendMode: { 
          value: 0.0, 
          editor: { 
            displayName: 'Layer Blend Mode',
            tooltip: '0:Normal, 1:Multiply, 2:Screen, 3:Overlay, 4:Darken, 5:Lighten, 6:Color Dodge, 7:Color Burn, 8:Hard Light, 9:Soft Light, 10:Difference, 11:Exclusion',
            range: [0, 11], 
            step: 1 
          } 
        }
        layerBlendIntensity: { value: 1.0, editor: { displayName: 'Layer Blend Intensity', range: [0, 1], step: 0.01 } }
        layerHue: { value: 0.0, editor: { displayName: 'Layer Hue', range: [-180, 180], step: 1 } }
        layerSaturation: { value: 0.0, editor: { displayName: 'Layer Saturation', range: [-100, 100], step: 1 } }
        layerValue: { value: 0.0, editor: { displayName: 'Layer Value', range: [-100, 100], step: 1 } }
        layerContrast: { value: 0.0, editor: { displayName: 'Layer Contrast', range: [-50, 100], step: 1 } }
        layerTintColor: { value: [1.0, 1.0, 1.0, 1.0], editor: { displayName: 'Layer Tint Color (RGBA)', type: 'color' } }
        layerColorInvert: { value: 0.0, editor: { displayName: 'Layer Color Invert', range: [0, 1], step: 1 } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 v_color;
  out vec2 v_uv0;
  out vec2 v_uv1;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    pos = cc_matViewProj * pos;

    v_uv0 = a_texCoord;
    v_uv1 = a_texCoord;  // 第二層也使用相同的原始 UV 坐標
    v_color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  // Blend Mode Reference:
  // 0=Normal, 1=Multiply, 2=Screen, 3=Overlay, 4=Darken, 5=Lighten
  // 6=ColorDodge, 7=ColorBurn, 8=HardLight, 9=SoftLight, 10=Difference, 11=Exclusion

  in vec4 v_color;
  in vec2 v_uv0;
  in vec2 v_uv1;

  uniform sampler2D mainTexture;
  uniform sampler2D layerTexture;

  uniform Constant {
    vec4 tilingOffset;        // 第一層 UV 控制
    vec4 layerTilingOffset;   // 第二層 UV 控制（獨立）
    vec4 layerTintColor;      // 第二層染色顏色 (RGB 顏色 + Alpha 混合強度)
    float layerOpacity;       // 第二層透明度
    float useLayer;           // 是否使用第二層
    float layerBlendMode;     // 第二層混合模式
    float layerBlendIntensity; // 第二層混合強度
    float layerHue;           // 第二層色相 (-180 ~ 180)
    float layerSaturation;    // 第二層飽和度 (-100 ~ 100, 0 = 正常)
    float layerValue;         // 第二層明度 (-100 ~ 100, 0 = 正常)
    float layerContrast;      // 第二層對比度 (-50 ~ 100, 0 = 正常)
    float layerColorInvert;   // 第二層反色 (0 = 正常, 1 = 反色)
    vec4 layerUVScale;        // 第二層 UV 縮放 (xy=scale, zw=unused, 預設 [1.0, 1.0, 0.0, 0.0])
  };

  // RGB 轉 HSV
  vec3 rgb2hsv(vec3 rgb) {
    float maxc = max(rgb.r, max(rgb.g, rgb.b));
    float minc = min(rgb.r, min(rgb.g, rgb.b));
    float v = maxc;
    float delta = maxc - minc;
    float s = (maxc != 0.0) ? delta / maxc : 0.0;
    float h = 0.0;
    
    if (delta != 0.0) {
      if (maxc == rgb.r) {
        h = mod((rgb.g - rgb.b) / delta, 6.0);
      } else if (maxc == rgb.g) {
        h = (rgb.b - rgb.r) / delta + 2.0;
      } else {
        h = (rgb.r - rgb.g) / delta + 4.0;
      }
      h = h / 6.0;
      if (h < 0.0) h += 1.0;
    }
    
    return vec3(h, s, v);
  }

  // HSV 轉 RGB
  vec3 hsv2rgb(vec3 hsv) {
    float c = hsv.z * hsv.y;
    float x = c * (1.0 - abs(mod(hsv.x * 6.0, 2.0) - 1.0));
    float m = hsv.z - c;
    
    vec3 rgb;
    if (hsv.x < 1.0 / 6.0) rgb = vec3(c, x, 0.0);
    else if (hsv.x < 2.0 / 6.0) rgb = vec3(x, c, 0.0);
    else if (hsv.x < 3.0 / 6.0) rgb = vec3(0.0, c, x);
    else if (hsv.x < 4.0 / 6.0) rgb = vec3(0.0, x, c);
    else if (hsv.x < 5.0 / 6.0) rgb = vec3(x, 0.0, c);
    else rgb = vec3(c, 0.0, x);
    
    return rgb + m;
  }

  // 調整第二層的 HSV 和對比度
  vec3 adjustLayerHSVC(vec3 color, float hue, float saturation, float value, float contrast) {
    // 轉換到 HSV
    vec3 hsv = rgb2hsv(color);
    
    // 調整色相（-180~180 到 -0.5~0.5）
    hsv.x = mod(hsv.x + hue / 360.0, 1.0);
    
    // 調整飽和度（-100~100，0 = 正常，負值降低飽和度，正值增加飽和度）
    hsv.y = hsv.y * (1.0 + saturation / 100.0);
    hsv.y = clamp(hsv.y, 0.0, 1.0);
    
    // 調整明度（-100~100，0 = 正常，負值變暗，正值變亮）
    hsv.z = hsv.z * (1.0 + value / 100.0);
    hsv.z = clamp(hsv.z, 0.0, 1.0);
    
    // 轉換回 RGB
    vec3 rgb = hsv2rgb(hsv);
    
    // 調整對比度（-50~100，0 = 正常）
    // contrast 正值: 增加對比度
    // contrast 負值: 降低對比度
    float contrastFactor = 1.0 + (contrast / 100.0);
    rgb = mix(vec3(0.5), rgb, contrastFactor);
    
    return clamp(rgb, 0.0, 1.0);
  }

  // 第二層混合模式 - Runtime 判斷（只作用於第二層）
  vec3 applyLayerBlendMode(vec3 base, vec3 blend, float blendMode, float intensity) {
    vec3 result = base;
    const float EPSILON = 0.001;
    float mode = blendMode;
    
    // 0: Normal
    if (mode < 0.5) {
      result = mix(base, blend, intensity);
    }
    // 1: Multiply
    else if (mode < 1.5) {
      result = mix(base, base * blend, intensity);
    }
    // 2: Screen
    else if (mode < 2.5) {
      vec3 screenResult = blend + base * (vec3(1.0) - blend);
      result = mix(base, screenResult, intensity);
    }
    // 3: Overlay
    else if (mode < 3.5) {
      vec3 overlayResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, base)
      );
      result = mix(base, overlayResult, intensity);
    }
    // 4: Darken
    else if (mode < 4.5) {
      result = mix(base, min(base, blend), intensity);
    }
    // 5: Lighten
    else if (mode < 5.5) {
      result = mix(base, max(base, blend), intensity);
    }
    // 6: Color Dodge
    else if (mode < 6.5) {
      vec3 dodgeResult = base / max(vec3(EPSILON), vec3(1.0) - blend);
      result = mix(base, dodgeResult, intensity);
    }
    // 7: Color Burn
    else if (mode < 7.5) {
      vec3 burnResult = vec3(1.0) - (vec3(1.0) - base) / max(vec3(EPSILON), blend);
      result = mix(base, burnResult, intensity);
    }
    // 8: Hard Light
    else if (mode < 8.5) {
      vec3 hardLightResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, blend)
      );
      result = mix(base, hardLightResult, intensity);
    }
    // 9: Soft Light
    else if (mode < 9.5) {
      result = mix(base, blend, intensity);
    }
    // 10: Difference
    else if (mode < 10.5) {
      result = mix(base, abs(base - blend), intensity);
    }
    // 11: Exclusion
    else if (mode < 11.5) {
      vec3 exclusionResult = base + blend - 2.0 * base * blend;
      result = mix(base, exclusionResult, intensity);
    }
    // Default: Normal
    else {
      result = mix(base, blend, intensity);
    }
    
    return clamp(result, 0.0, 1.0);
  }

  vec4 frag () {
    // ===== 第一層（底層）- 受 tilingOffset 影響 =====
    vec2 uv0 = v_uv0 * tilingOffset.xy + tilingOffset.zw;
    uv0 = fract(uv0);
    
    vec4 baseColor = texture(mainTexture, uv0);
    baseColor *= v_color;

    // ===== 第二層（頂層）- 獨立的 UV 系統 =====
    vec4 finalColor = baseColor;
    
    if (useLayer > 0.5) {
      // 第二層使用完全獨立的 UV 系統，不受 tilingOffset 影響
      vec2 uv1 = v_uv1 * layerTilingOffset.xy + layerTilingOffset.zw;
      
      // 應用 UV 縮放 (中心點縮放，避免偏移)
      uv1 = (uv1 - 0.5) * layerUVScale.xy + 0.5;
      
      uv1 = fract(uv1);
      
      vec4 layerColor = texture(layerTexture, uv1);
      
      // 調整第二層的 HSV 和對比度
      vec3 adjustedLayerColor = adjustLayerHSVC(layerColor.rgb, layerHue, layerSaturation, layerValue, layerContrast);
      
      // 應用 Color Invert（如果啟用）
      adjustedLayerColor = mix(adjustedLayerColor, vec3(1.0) - adjustedLayerColor, layerColorInvert);
      
      // 應用 Tint Color 到第二層（layerTintColor 已經是 0-1 範圍，直接使用）
      vec3 tintedLayerColor = mix(adjustedLayerColor, adjustedLayerColor * layerTintColor.rgb, layerTintColor.a);
      
      // 計算第二層的有效透明度（0-100 轉換為 0-1）
      float effectiveOpacity = layerOpacity / 100.0;
      
      // 應用第二層混合模式（使用 tinted color）
      vec3 blendedRGB = applyLayerBlendMode(baseColor.rgb, tintedLayerColor, layerBlendMode, layerBlendIntensity);
      
      // 混合 RGB 和 Alpha - layerOpacity 控制第二層的覆蓋強度
      vec3 finalRGB = mix(baseColor.rgb, blendedRGB, effectiveOpacity);
      float finalAlpha = mix(baseColor.a, 1.0, effectiveOpacity);
      
      finalColor = vec4(finalRGB, finalAlpha);
    }

    ALPHA_TEST(finalColor);
    return finalColor;
  }
}%
