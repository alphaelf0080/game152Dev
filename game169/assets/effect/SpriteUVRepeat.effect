// Sprite UV Repeat Shader with Second Layer
// 支援第二層獨立紋理，擁有獨立的 UV 系統
// Cocos Creator 3.8

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        
        # 第一層（底層）紋理
        mainTexture: { value: white }
        tilingOffset: { value: [1.0, 1.0, 0.0, 0.0] }
        
        # 第二層（頂層）紋理 - 獨立 UV 系統
        layerTexture: { value: white }
        layerTilingOffset: { value: [1.0, 1.0, 0.0, 0.0] }
        layerOpacity: { value: 1.0 }
        useLayer: { value: 0.0 }
        layerBlendMode: { value: 0.0, editor: { displayName: 'Layer Blend Mode', tooltip: '0=Normal, 1=Multiply, 2=Screen, 3=Overlay, 4=Darken, 5=Lighten, 6=Color Dodge, 7=Color Burn, 8=Hard Light, 9=Soft Light, 10=Difference, 11=Exclusion, 12=Hue, 13=Saturation, 14=Color, 15=Luminosity' } }
        layerBlendIntensity: { value: 1.0, editor: { displayName: 'Layer Blend Intensity', tooltip: '0=完全使用底層, 1=完全使用 Blend 結果' } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 v_color;
  out vec2 v_uv0;
  out vec2 v_uv1;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    pos = cc_matViewProj * pos;

    v_uv0 = a_texCoord;
    v_uv1 = a_texCoord;  // 第二層也使用相同的原始 UV 坐標
    v_color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  in vec4 v_color;
  in vec2 v_uv0;
  in vec2 v_uv1;

  uniform sampler2D mainTexture;
  uniform sampler2D layerTexture;

  #pragma define-meta LAYER_BLEND_MODE range([0, 15])

  uniform Constant {
    vec4 tilingOffset;        // 第一層 UV 控制
    vec4 layerTilingOffset;   // 第二層 UV 控制（獨立）
    float layerOpacity;       // 第二層透明度
    float useLayer;           // 是否使用第二層
    float layerBlendMode;     // 第二層混合模式
    float layerBlendIntensity; // 第二層混合強度
  };

  // 輔助函數：獲取亮度值
  float getLuminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
  }

  // 輔助函數：設置指定顏色的亮度值
  vec3 setLuminance(vec3 c, float l) {
    float d = l - getLuminance(c);
    return c + vec3(d);
  }

  // 輔助函數：計算顏色的飽和度
  float getSaturation(vec3 c) {
    return max(max(c.r, c.g), c.b) - min(min(c.r, c.g), c.b);
  }

  // 輔助函數：飽和度調整
  vec3 setSaturationValue(vec3 c, float s) {
    float l = getLuminance(c);
    vec3 grey = vec3(l);
    return mix(grey, c, s);
  }

  // 混合模式函數
  vec3 applyLayerBlendMode(vec3 base, vec3 blend, float blendMode, float intensity) {
    vec3 result = base;
    const float EPSILON = 0.00001;
    
    // 根據 blendMode 應用不同的混合模式
    if (blendMode < 0.5) {
      // 0: Normal
      result = mix(base, blend, intensity);
    } else if (blendMode < 1.5) {
      // 1: Multiply
      result = mix(base, base * blend, intensity);
    } else if (blendMode < 2.5) {
      // 2: Screen
      vec3 screenResult = blend + base * (vec3(1.0) - blend);
      result = mix(base, screenResult, intensity);
    } else if (blendMode < 3.5) {
      // 3: Overlay
      vec3 overlayResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, base)
      );
      result = mix(base, overlayResult, intensity);
    } else if (blendMode < 4.5) {
      // 4: Darken
      result = mix(base, min(base, blend), intensity);
    } else if (blendMode < 5.5) {
      // 5: Lighten
      result = mix(base, max(base, blend), intensity);
    } else if (blendMode < 6.5) {
      // 6: Color Dodge
      vec3 dodgeResult = base / max(vec3(EPSILON), vec3(1.0) - blend);
      result = mix(base, dodgeResult, intensity);
    } else if (blendMode < 7.5) {
      // 7: Color Burn
      vec3 burnResult = vec3(1.0) - (vec3(1.0) - base) / max(vec3(EPSILON), blend);
      result = mix(base, burnResult, intensity);
    } else if (blendMode < 8.5) {
      // 8: Hard Light
      vec3 hardLightResult = mix(
        2.0 * base * blend,
        vec3(1.0) - 2.0 * (vec3(1.0) - base) * (vec3(1.0) - blend),
        step(0.5, blend)
      );
      result = mix(base, hardLightResult, intensity);
    } else if (blendMode < 9.5) {
      // 9: Soft Light
      vec3 usePoly = step(base, vec3(0.25));
      vec3 Gpoly = ((vec3(16.0) * base - vec3(12.0)) * base + vec3(4.0)) * base;
      vec3 G = usePoly * Gpoly + (vec3(1.0) - usePoly) * sqrt(base);
      
      vec3 A = base - (vec3(1.0) - 2.0 * blend) * base * (vec3(1.0) - base);
      vec3 B = base + (2.0 * blend - vec3(1.0)) * (G - base);
      
      vec3 softLightResult = mix(A, B, step(vec3(0.5), blend));
      result = mix(base, softLightResult, intensity);
    } else if (blendMode < 10.5) {
      // 10: Difference
      result = mix(base, abs(base - blend), intensity);
    } else if (blendMode < 11.5) {
      // 11: Exclusion
      vec3 exclusionResult = base + blend - 2.0 * base * blend;
      result = mix(base, exclusionResult, intensity);
    } else if (blendMode < 12.5) {
      // 12: Hue
      float s = getSaturation(base);
      float l = getLuminance(base);
      vec3 hueResult = setLuminance(setSaturationValue(blend, s), l);
      result = mix(base, hueResult, intensity);
    } else if (blendMode < 13.5) {
      // 13: Saturation
      float s = getSaturation(blend);
      float l = getLuminance(base);
      vec3 satResult = setLuminance(setSaturationValue(base, s), l);
      result = mix(base, satResult, intensity);
    } else if (blendMode < 14.5) {
      // 14: Color
      vec3 colorResult = setLuminance(blend, getLuminance(base));
      result = mix(base, colorResult, intensity);
    } else {
      // 15: Luminosity
      vec3 lumResult = setLuminance(base, getLuminance(blend));
      result = mix(base, lumResult, intensity);
    }
    
    return clamp(result, 0.0, 1.0);
  }

  vec4 frag () {
    // ===== 第一層（底層）- 受 tilingOffset 影響 =====
    vec2 uv0 = v_uv0 * tilingOffset.xy + tilingOffset.zw;
    uv0 = fract(uv0);
    
    vec4 baseColor = texture(mainTexture, uv0);
    baseColor *= v_color;

    // ===== 第二層（頂層）- 獨立的 UV 系統 =====
    vec4 finalColor = baseColor;
    
    if (useLayer > 0.5) {
      // 第二層使用完全獨立的 UV 系統，不受 tilingOffset 影響
      vec2 uv1 = v_uv1 * layerTilingOffset.xy + layerTilingOffset.zw;
      uv1 = fract(uv1);
      
      vec4 layerColor = texture(layerTexture, uv1);
      
      // 應用混合模式
      vec3 blendedRGB = applyLayerBlendMode(baseColor.rgb, layerColor.rgb, layerBlendMode, layerBlendIntensity);
      
      // Alpha 混合（基於 layerColor 的 alpha 和 layerOpacity）
      float finalAlpha = mix(baseColor.a, layerColor.a, layerColor.a * layerOpacity);
      
      finalColor = vec4(blendedRGB, finalAlpha);
    }

    ALPHA_TEST(finalColor);
    return finalColor;
  }
}%
