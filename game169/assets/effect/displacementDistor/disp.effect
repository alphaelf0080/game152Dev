// Cocos Creator Displacement Distortion Effect
// 用於根據灰階貼圖進行畫面扭曲的後處理效果

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        displacementMap: { value: white, editor: { displayName: '位移貼圖' } }
        displacementStrength: { value: 0.1, target: displacementParams.x, editor: { displayName: '位移強度', tooltip: '位移強度', range: [0.0, 1.0], slide: true } }
        displacementScale: { value: 1.0, target: displacementParams.y, editor: { displayName: '位移縮放', tooltip: '位移縮放' } }
        timeSpeed: { value: 1.0, target: displacementParams.z, editor: { displayName: '動畫速度', tooltip: '動畫速度' } }
        distortionType: { value: 0.0, target: displacementParams.w, editor: { displayName: '扭曲類型', tooltip: '扭曲類型: 0=XY, 1=X, 2=Y, 3=Radial' } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  #if SAMPLE_FROM_RT
    #include <common/common-define>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 color;
  out vec2 uv0;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    #if USE_PIXEL_ALIGNMENT
      pos = cc_matView * pos;
      pos.xyz = floor(pos.xyz);
      pos = cc_matProj * pos;
    #else
      pos = cc_matViewProj * pos;
    #endif

    uv0 = a_texCoord;
    #if SAMPLE_FROM_RT
      CC_HANDLE_RT_SAMPLE_FLIP(uv0);
    #endif
    color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>
  
  in vec4 color;
  in vec2 uv0;
  
  #pragma builtin(local)
  layout(set = 2, binding = 11) uniform sampler2D cc_spriteTexture;
  
  uniform sampler2D displacementMap;
  
  uniform DisplacementParams {
    vec4 displacementParams;
  };
  
  vec4 frag () {
    // 讀取位移貼圖 (灰階值)
    vec2 displacementUV = uv0 * displacementParams.y;
    
    // 加入時間動畫 (可選)
    float time = cc_time.x * displacementParams.z;
    displacementUV += vec2(time * 0.1, time * 0.05);
    
    vec4 displacementColor = texture(displacementMap, displacementUV);
    
    // 將灰階值轉換為位移向量 (0.5 為中心點，不位移)
    vec2 displacement = (displacementColor.rg - 0.5) * 2.0;
    
    // 根據扭曲類型調整位移
    int type = int(displacementParams.w);
    if (type == 1) {
      // 只有 X 軸位移
      displacement.y = 0.0;
    } else if (type == 2) {
      // 只有 Y 軸位移
      displacement.x = 0.0;
    } else if (type == 3) {
      // 徑向扭曲
      vec2 centerOffset = uv0 - 0.5;
      float dist = length(centerOffset);
      float angle = atan(centerOffset.y, centerOffset.x);
      float radialDisplacement = (displacementColor.r - 0.5) * 2.0;
      displacement = vec2(cos(angle), sin(angle)) * radialDisplacement * dist;
    }
    
    // 應用位移強度
    displacement *= displacementParams.x;
    
    // 從主紋理採樣位移後的 UV
    vec2 distortedUV = uv0 + displacement;
    
    // 確保 UV 在有效範圍內 (可選: clamp 或 wrap)
    distortedUV = clamp(distortedUV, 0.0, 1.0);
    
    vec4 o = texture(cc_spriteTexture, distortedUV);
    
    // 應用頂點顏色
    o *= color;
    
    ALPHA_TEST(o);
    
    return o;
  }
}%
