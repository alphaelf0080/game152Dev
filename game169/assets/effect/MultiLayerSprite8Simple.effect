// Multi-Layer Sprite Shader (8 Layers - Simplified)
// 簡化版：支援 8 層 SpriteFrame 基本疊加
// 功能：
// - 8 層各有獨立的 SpriteFrame
// - 每層可獨立調整 UV Scale、Repeat、Offset、Opacity
// - 支援 Wrap Mode：Clamp (0)、Repeat (1)、Mirror (2)
// - 移除 HSV 色彩調整
// - 移除混合模式（使用簡單的 Alpha 混合）
// - 支援 Clamp 邊界透明化

CCEffect %{
  techniques:
  - passes:
    - vert: sprite-vs:vert
      frag: sprite-fs:frag
      depthStencilState:
        depthTest: false
        depthWrite: false
      blendState:
        targets:
        - blend: true
          blendSrc: src_alpha
          blendDst: one_minus_src_alpha
          blendDstAlpha: one_minus_src_alpha
      rasterizerState:
        cullMode: none
      properties:
        alphaThreshold: { value: 0.5 }
        
        # 第 0 層（底層）
        mainTexture: { value: white }
        layer0Scale: { value: [1.0, 1.0] }
        layer0Repeat: { value: [1.0, 1.0] }
        layer0Offset: { value: [0.0, 0.0] }
        layer0WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer0Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 1 層
        layer1Texture: { value: white }
        layer1Scale: { value: [1.0, 1.0] }
        layer1Repeat: { value: [1.0, 1.0] }
        layer1Offset: { value: [0.0, 0.0] }
        layer1WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer1Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 2 層
        layer2Texture: { value: white }
        layer2Scale: { value: [1.0, 1.0] }
        layer2Repeat: { value: [1.0, 1.0] }
        layer2Offset: { value: [0.0, 0.0] }
        layer2WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer2Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 3 層
        layer3Texture: { value: white }
        layer3Scale: { value: [1.0, 1.0] }
        layer3Repeat: { value: [1.0, 1.0] }
        layer3Offset: { value: [0.0, 0.0] }
        layer3WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer3Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 4 層
        layer4Texture: { value: white }
        layer4Scale: { value: [1.0, 1.0] }
        layer4Repeat: { value: [1.0, 1.0] }
        layer4Offset: { value: [0.0, 0.0] }
        layer4WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer4Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 5 層
        layer5Texture: { value: white }
        layer5Scale: { value: [1.0, 1.0] }
        layer5Repeat: { value: [1.0, 1.0] }
        layer5Offset: { value: [0.0, 0.0] }
        layer5WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer5Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 6 層
        layer6Texture: { value: white }
        layer6Scale: { value: [1.0, 1.0] }
        layer6Repeat: { value: [1.0, 1.0] }
        layer6Offset: { value: [0.0, 0.0] }
        layer6WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer6Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
        
        # 第 7 層
        layer7Texture: { value: white }
        layer7Scale: { value: [1.0, 1.0] }
        layer7Repeat: { value: [1.0, 1.0] }
        layer7Offset: { value: [0.0, 0.0] }
        layer7WrapMode: { value: 0.0, editor: { range: [0, 2], step: 1 } }
        layer7Opacity: { value: 100.0, editor: { range: [0, 100], step: 1 } }
}%

CCProgram sprite-vs %{
  precision highp float;
  #include <builtin/uniforms/cc-global>
  #if USE_LOCAL
    #include <builtin/uniforms/cc-local>
  #endif
  
  in vec3 a_position;
  in vec2 a_texCoord;
  in vec4 a_color;

  out vec4 v_color;
  out vec2 v_uv;

  vec4 vert () {
    vec4 pos = vec4(a_position, 1);

    #if USE_LOCAL
      pos = cc_matWorld * pos;
    #endif

    pos = cc_matViewProj * pos;

    v_uv = a_texCoord;
    v_color = a_color;

    return pos;
  }
}%

CCProgram sprite-fs %{
  precision highp float;
  #include <builtin/internal/embedded-alpha>
  #include <builtin/internal/alpha-test>

  in vec4 v_color;
  in vec2 v_uv;

  uniform sampler2D mainTexture;
  uniform sampler2D layer1Texture;
  uniform sampler2D layer2Texture;
  uniform sampler2D layer3Texture;
  uniform sampler2D layer4Texture;
  uniform sampler2D layer5Texture;
  uniform sampler2D layer6Texture;
  uniform sampler2D layer7Texture;

  uniform Constant {
    vec2 layer0Scale;
    vec2 layer0Repeat;
    vec2 layer0Offset;
    float layer0WrapMode;
    float layer0Opacity;
    
    vec2 layer1Scale;
    vec2 layer1Repeat;
    vec2 layer1Offset;
    float layer1WrapMode;
    float layer1Opacity;
    
    vec2 layer2Scale;
    vec2 layer2Repeat;
    vec2 layer2Offset;
    float layer2WrapMode;
    float layer2Opacity;
    
    vec2 layer3Scale;
    vec2 layer3Repeat;
    vec2 layer3Offset;
    float layer3WrapMode;
    float layer3Opacity;
    
    vec2 layer4Scale;
    vec2 layer4Repeat;
    vec2 layer4Offset;
    float layer4WrapMode;
    float layer4Opacity;
    
    vec2 layer5Scale;
    vec2 layer5Repeat;
    vec2 layer5Offset;
    float layer5WrapMode;
    float layer5Opacity;
    
    vec2 layer6Scale;
    vec2 layer6Repeat;
    vec2 layer6Offset;
    float layer6WrapMode;
    float layer6Opacity;
    
    vec2 layer7Scale;
    vec2 layer7Repeat;
    vec2 layer7Offset;
    float layer7WrapMode;
    float layer7Opacity;
  };

  // Wrap Mode 處理（帶 Clamp 邊界透明化）
  vec4 applyWrapModeWithClamp(vec2 uv, float wrapMode) {
    float mode = wrapMode;
    if (mode < 0.5) {
      // Clamp 模式：邊界外透明
      vec2 clampedUV = clamp(uv, 0.0, 1.0);
      bool inBounds = (uv == clampedUV);
      return vec4(clampedUV, inBounds ? 1.0 : 0.0, 0.0);
    } else if (mode < 1.5) {
      // Repeat 模式
      return vec4(fract(uv), 1.0, 0.0);
    } else {
      // Mirror 模式
      vec2 mirrorUV = mod(uv, 2.0);
      if (mirrorUV.x > 1.0) mirrorUV.x = 2.0 - mirrorUV.x;
      if (mirrorUV.y > 1.0) mirrorUV.y = 2.0 - mirrorUV.y;
      return vec4(mirrorUV, 1.0, 0.0);
    }
  }

  // 處理 UV 變換
  vec3 processUV(vec2 uv, vec2 scale, vec2 repeat, vec2 offset, float wrapMode) {
    vec2 scaledUV = (uv - 0.5) * scale + 0.5;
    vec2 repeatedUV = scaledUV * repeat;
    vec2 offsetUV = repeatedUV + offset;
    
    vec4 wrapResult = applyWrapModeWithClamp(offsetUV, wrapMode);
    return vec3(wrapResult.xy, wrapResult.z);
  }

  vec4 frag () {
    // 第 0 層（底層）
    vec3 uv0Data = processUV(v_uv, layer0Scale, layer0Repeat, layer0Offset, layer0WrapMode);
    vec4 layer0Color = texture(mainTexture, uv0Data.xy);
    layer0Color *= v_color;
    layer0Color.a *= (layer0Opacity / 100.0) * uv0Data.z;
    
    vec4 result = layer0Color;

    // 第 1 層 - 簡單 Alpha 混合
    vec3 uv1Data = processUV(v_uv, layer1Scale, layer1Repeat, layer1Offset, layer1WrapMode);
    vec4 layer1Color = texture(layer1Texture, uv1Data.xy);
    float layer1Alpha = (layer1Opacity / 100.0) * layer1Color.a * uv1Data.z;
    result.rgb = mix(result.rgb, layer1Color.rgb, layer1Alpha);
    result.a = mix(result.a, 1.0, layer1Alpha);

    // 第 2 層
    vec3 uv2Data = processUV(v_uv, layer2Scale, layer2Repeat, layer2Offset, layer2WrapMode);
    vec4 layer2Color = texture(layer2Texture, uv2Data.xy);
    float layer2Alpha = (layer2Opacity / 100.0) * layer2Color.a * uv2Data.z;
    result.rgb = mix(result.rgb, layer2Color.rgb, layer2Alpha);
    result.a = mix(result.a, 1.0, layer2Alpha);

    // 第 3 層
    vec3 uv3Data = processUV(v_uv, layer3Scale, layer3Repeat, layer3Offset, layer3WrapMode);
    vec4 layer3Color = texture(layer3Texture, uv3Data.xy);
    float layer3Alpha = (layer3Opacity / 100.0) * layer3Color.a * uv3Data.z;
    result.rgb = mix(result.rgb, layer3Color.rgb, layer3Alpha);
    result.a = mix(result.a, 1.0, layer3Alpha);

    // 第 4 層
    vec3 uv4Data = processUV(v_uv, layer4Scale, layer4Repeat, layer4Offset, layer4WrapMode);
    vec4 layer4Color = texture(layer4Texture, uv4Data.xy);
    float layer4Alpha = (layer4Opacity / 100.0) * layer4Color.a * uv4Data.z;
    result.rgb = mix(result.rgb, layer4Color.rgb, layer4Alpha);
    result.a = mix(result.a, 1.0, layer4Alpha);

    // 第 5 層
    vec3 uv5Data = processUV(v_uv, layer5Scale, layer5Repeat, layer5Offset, layer5WrapMode);
    vec4 layer5Color = texture(layer5Texture, uv5Data.xy);
    float layer5Alpha = (layer5Opacity / 100.0) * layer5Color.a * uv5Data.z;
    result.rgb = mix(result.rgb, layer5Color.rgb, layer5Alpha);
    result.a = mix(result.a, 1.0, layer5Alpha);

    // 第 6 層
    vec3 uv6Data = processUV(v_uv, layer6Scale, layer6Repeat, layer6Offset, layer6WrapMode);
    vec4 layer6Color = texture(layer6Texture, uv6Data.xy);
    float layer6Alpha = (layer6Opacity / 100.0) * layer6Color.a * uv6Data.z;
    result.rgb = mix(result.rgb, layer6Color.rgb, layer6Alpha);
    result.a = mix(result.a, 1.0, layer6Alpha);

    // 第 7 層
    vec3 uv7Data = processUV(v_uv, layer7Scale, layer7Repeat, layer7Offset, layer7WrapMode);
    vec4 layer7Color = texture(layer7Texture, uv7Data.xy);
    float layer7Alpha = (layer7Opacity / 100.0) * layer7Color.a * uv7Data.z;
    result.rgb = mix(result.rgb, layer7Color.rgb, layer7Alpha);
    result.a = mix(result.a, 1.0, layer7Alpha);

    ALPHA_TEST(result);
    return result;
  }
}%
